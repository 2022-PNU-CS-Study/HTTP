# HTTP 2.0
> 책 내용과 지금은 차이가 있을 수 있다.
- [HTTP 2.0](#http-20)
  - [등장 배경](#등장-배경)
  - [개요](#개요)
  - [HTTP/1.1과 차이점](#http11과-차이점)
    - [프레임](#프레임)
      - [헤더](#헤더)
    - [스트림과 멀티플렉싱](#스트림과-멀티플렉싱)
    - [헤더 압축](#헤더-압축)
    - [서버 푸시](#서버-푸시)
  - [보안 이슈](#보안-이슈)
    - [중개자 캡슐화 공격](#중개자-캡슐화-공격)
    - [긴 커넥션 유지로 인한 개인정보 누출 우려](#긴-커넥션-유지로-인한-개인정보-누출-우려)

## 등장 배경
- 구현의 단순성과 접근성에 초점
- 성능이 어느정도 희생됨
- HTTP는 동기화되어있기 때문에 다음 요청을 기다려야한다.
- 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 근본적인 해결 안됨

## 개요
- HTTP/2.0은  TCP 커넷견 위에서 동작
- 클라이언트가 TCP 커넥션 초기화
- 요청과 응답은 길이가 정의된 한개 이상의 프레임으로 전달
- HTTP 헤더는 압축되어 있다.
- 스트림을 통해 전달
  - 한개의 스트림이 한쌍의 요청와 응답을 처리
  - 하나의 커넥션 위에 여러개의 스트림 생성 가능
  - 동시 처리 가능
  - 흐름 제어와 우선순위 부여 기능 제공
- 요청-응답이 아닌 서버 푸시 도입
- 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 명시적으로 받지 않아도 능동적으로 전달 가능
- 호환성을 위해 HTTP/1.0과 요청-응답 메시지의 의미 같게 유지

## HTTP/1.1과 차이점
### 프레임
- 모든 프레임은 8바이트 크기의 헤더로 시작
- 최대 16383 바이트 크기의 페이로드
  
#### 헤더
- R
  - 2비트
  - 값의 의미가 정의되어있지 않음
  - 반드시 0
  - 받는 쪽에서는 무시
- 길이
  - 페이로드의 길이를 나타냄
  - 14비트의 unsigned integer
  - 헤더는 길이에 포함 안됨
- 종류
  - 프레임 종류
- 플래그
  - 8비트
- 스트림 식별자
  - 31비트 스트림 식별자
  - 0은 커넥션 전체와 연관된 프레임을 의미

### 스트림과 멀티플렉싱
- 스트림은 프레임들의 독립된 양방향 시퀀스
- 한쌍의 요청과 응답은 하나의 스트림을 통해 이루어짐
- 요청 받은 서버는 동일한 스트림으로 응답
- 응답 후 스트림 닫힘
- HTTP/1.1은 도착했다는 것을 확인해야 다음 요청 보낼 수 있다.
- HTTP/1.1은 보통 여러개의 TCP를 만들어서 동시에 전달 
  - 무한개를 연결할 수 없다
- HTTP/2.0은 하나의 커넥션에 여러개의 스트림 동시에 가능
- 스트림은 우선 순위를 가질 수 있다.
- 우선순위는 의무사항이 아니기 때문에 항상 보장되지 않는다.
- 클라이언트가 스트림을 초기화했다면 식별자는 반드시 홀수, 서버가 초기화하면 짝수
- 새로운 스트림은 이전 스트림과 예약된 스트림의 식별자 보다 커야한다.
  - 해당 규칙을 어기면 PROTOCOL_ERROR인 커넥션 에러
- 스트림을 협상 없이 만듬
  - TCP 패킷을 주고받으면서 사용하는 시간 없음
  - 악수 안함
- 한번 사용한 스트림 식별자는 사용할 수 없다.
  - 식별자가 고갈된 경우 다시 커넥션 형성
- 흐름제어를 통해 서로 간섭하는 것을 막음

### 헤더 압축
- HPACK 명세에 정의된 방법으로 헤더 압축   
  - 압축 콘텍스트(compression context)를 사용
  - 수신한 헤더의 압축을 풀면 영향을 받아 바뀜
  - 송신측은 헤더 압축이 풀렸고 변경되었다고 가정함
  - 수신측은 버려도 압축 해제를 해야함
- 헤더 블록 조각들로 쪼개져서 전송
- 받는 쪽에서 조각을 맞춰서 압축을 푼다.

### 서버 푸시
- 하나의 요청에 응답을 여러개로 보낼 수 있다
- 리소스를 푸시하는 서버는 클라이언트이 푸시할거라고 알린다.
  - PUSH_PROMISE 프레임을 보내서 알려줌
  - 해당 프레임의 스트림은 `예약` 상태가 된다.
  - 클라이언트가 RST_STREAM 프레임을 보내서 거절할 수 있다. 

## 보안 이슈
### 중개자 캡슐화 공격
- 중간의 프록시가 HTTP/1.1로 변환할 때 메시지의 의미가 변질될 가능성있음
- HTTP/2.0은 헤더를 바이너리로 인코딩하는데 HTTP/1.1이 해당 바이너리를 불법적이거나 위조된 메시지로 번역할 수 있다.
- 반대의 경우에는 발생하지 않는다.

### 긴 커넥션 유지로 인한 개인정보 누출 우려
- 클라이언트-서버 커넥션을 오래 유지하면 개인 정보 유출 가능성이이 ㅆ다
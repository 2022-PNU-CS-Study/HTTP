# Chap 14 (보안 HTTP)

> HTTP 에서 데이터를 안전하게 전송하기 위해 어떤 방법들을 사용하는지 알아보자.

## HTTP를 안전하게 만들기

HTTP 보안은 다음과 같은 기능들을 제공해야한다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜 서버와 이야기 하는 것이 보장되어야 한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기 하는 것이 보장되어야 한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### HTTPS

- 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
- HTTP 하위 계층에 보안 계층을 제공함으로써 동작한다. → SSL(Secure Sockets Layer)와 TLS(Transport Layer Security)
- TLS와 SSL은 매우 비슷하며 관례적으로 SSL 표현을 많이 사용한다. (TLS는 SSL을 확장 시킨 것)
- 넷스케이프에서 개척하였으며 모든 주류 브라우저와 서버에서 지원한다.

![Image](https://res.craft.do/user/full/8884c80f-6eec-6a29-2a03-049def967beb/doc/2B90ADA3-92F6-4C08-9CA9-E85A6EC31E36/2E72CC2F-5E31-495E-A0E4-93BE2A6B3D63_2/oqnJZxl5oMWCiSNQtBBYmTgaGnx3t3fIPdq9CxNjEJ8z/Image)

## 디지털 암호학

- 암호 - 텍스트를 아무나 읽지 못하도록 인코딩 하는 알고리즘
- 키 - 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 - 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 - 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 - 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 - 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 - 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

## 대칭키 암호법

- 인코딩할 때 키와 디코딩 할 때 키가 같으면 대칭키라고 한다.
- 잘 알려진 대칭키 암호 알고리즘은 DES, Triple-DES, RC2, RC4 등이 있다.
- 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다.
- 발송자는 평문을 k로 암호화하여 수신자에게 발송하고, 수신자는 암호문을 수신하여 k로 복호화한다.

단점

- 클라이언트는 서버와 암호화 된 대화를 하기 위해 클라이언트와 서버만의 개인 비밀 키를 발급해야 한다.
- 그러려면 비밀 키를 발급하고 그것을 기억할 방법이 필요하다.
- 클라이언트가 수천 개 라면 서버는 수천 개의 비밀 키를 생성하고 기억해야 할 것이다.
- 그 키를 관리해야 하는 사람 입장에서 이것은 지옥이다.
- 노드의 개수가 N개라면 N^2만큼의 개인키가 필요하다.

![Image](https://res.craft.do/user/full/8884c80f-6eec-6a29-2a03-049def967beb/doc/2B90ADA3-92F6-4C08-9CA9-E85A6EC31E36/D5A16F60-BB5E-46C0-90D4-D40654244878_2/5cGma17EI0OMKTNnSUaVxkqu5GnEqa652opfXzTb8Rgz/Image)

## 공개키(비대칭키) 암호법

- 클라이언트와 서버 사이에 키를 두개 사용한다. 하나는 인코딩을 위한 것, 다른 하나는 디코딩을 위한 것
- 인코딩 키는 모두에게 공개되어 있지만 디코딩 키는 호스트만이 알고 있다.
- 키를 관리하는 일이 대칭키일 때보다 줄어든다. 노드가 N개 있을 때, 나의 개인키 하나와 N-1개의 공개키를 가지면 된다.
- 모든 사람이 동일한 키로 메시지를 인코딩 해서 X에게 보내지만, 메시지를 받는 X를 제외하고는 그 누구도 메시지를 디코딩할 수 없다. 오직 메시지를 받는 X만 개인 디코딩 키를 갖고 있기 때문이다.
- 여기서 호스트라 함은 일반적으로 서버를 말한다고 생각하면 되겠다.

### 공개키의 과제

공개키 비대칭 암호의 과제는, 악당이 아래의 내용을 알고 있다 하더라고 비밀인 개인키를 계산할 수 없음을 확신시켜 주는것이다.

- 공개키(공개니까 누구나 얻을 수 있음)
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 MIT에서 발명되고 이어서 RSA 데이터 시큐리티에서 상용화된 `RSA 알고리즘` 이다.

### 디지털 서명

- 이전까지 설명한 암호체계의 쓰임은 암, 복호화에만 국한되지는 않는다.
- 누가 메시지를 썼는지 알려주고, 그 메시지가 위조되지 않음을 증명하기 위해 메시지에 **서명**을 하는 데에 이용될 수 있다.

> 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다.

- 서명은 메시지를 작성한 저자가 누구인지 알려준다. 저자는 저자의 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 '서명' 처럼 동작한다.
- 서명은 메시지 위조를 방지한다. 악의적인 공격자가 송신중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 된다. 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조할 수 없다.

### 디지털 서명 동작 과정

![14-10.png](https://github.com/kimmin-ko/HTTP-The-Definitive-Guide/blob/master/images/14-10.png?raw=true)

- A는 가변 길이 메시지를 정제하여 고정된 길이의 digest로 만든다.
- A는 그 Digest에, 사용자의 Secret Key를 매개변수로 하는 Signature 함수를 적용한다.
- 오직 그 사용자만이 Secret Key를 알고 있기 때문에, 올바른 서명 함수는 서명자가 소유자임을 보여준다.
- 서명 함수로 디코더 함수 D를 사용한 이유는, 그 함수가 사용자의 Secret Key와 관련되어 있기 때문이다.
- 한번 서명이 계산되면, A는 그것을 메시지의 끝에 덧붙이고, 메시지와 그에 대한 서명 둘 다를 B에게 전송한다.
- B는 발송자가 A이며 메시지가 위조되지 않았다는 것을 증명하기 위해 서명을 검사할 수 있다.
- B는 A의 Secret Key로 변형된 Signature에 Public Key를 이용한 역함수를 적용한다.
- 만약 풀어낸 Digest가 B가 갖고 있는 Digest와 다르다면, 메시지가 송신 중에 위조되었거나 아니면 발송자가 A의 Secret Key를 갖고있지 않는 것이다. (즉, 메시지를 쓴 것은 A가 아니다)

## 디지털 인증서

> 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

사용자가 HTTPS를 통한 웹 트랜젝션을 시작할 때, 브라우저는 자동으로 `접속한 서버에서 디지털 인증서를 가져온다`. **서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다**.

서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저는 인증서를 받으면 서명 기관을 검사한다. 그 기관이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이다. 만약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기관을 신뢰할 것인지에 대한 판단을 사용자에게 넘긴다.

## HTTPS

> HTTPS 는 특별한게 아니라 그저 보안 전송 계층(SSL)을 통하는 HTTP 이다.

- HTTP: 메시지를 TCP를 통해 보낸다.
- HTTPS: 메시지를 보안 계층으로 보내 암호화한 뒤 TCP를 통해 보낸다.

![Image](https://res.craft.do/user/full/8884c80f-6eec-6a29-2a03-049def967beb/doc/2B90ADA3-92F6-4C08-9CA9-E85A6EC31E36/A6E0EE1F-F883-4A48-9C1A-6B01F1ABBA98_2/y5t9sg6w0HxKpFjzFoBTZ5SfFdLJkq1RftitENJxlPEz/Image)

HTTP, HTTPS는 필요에 따라 사용하고 보통은 둘다 사용할 수 있게 하거나 보안 연결만 가능하게 한다.

https로 접근하게 되면 바이너리 포맷으로 된 SSL 보안 매개변수를 교환하면서 '핸드셰이크'를 한 후, 암호화된 HTTP 명령을 보내게 된다.

- http 스킴을 가지고 있다면

클라이언트는 서버에 80(기본값) 포트로 연결하고 평범한 HTTP 명령을 전송한다.

- https 스킴을 가지고 있다면

클라이언트는 서버에 443(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서

'핸드셰이크'를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

### SSL 셋업

HTTPS는 기존 HTTP 통신 절차보다 훨씬 복잡한 과정을 거친다.

1. 클라이언트가 HTTPS로 접근을 하면 TCP 커넥션을 맺고
2. SSL 계층에서 암호 매개변수와 교환 키를 협상한다(핸드셰이크)
3. SSL 초기화가 완료되었고, 클라이언트는 요청 메시지를 SSL을 통해 보낸다.
4. SSL 을 통과하여 암호화가 완료된 메시지는 TCP 커넥션으로 전송된다.

### SSL 핸드셰이크

위 과정에서 2번째 단계인 SSL 핸드셰이크 과정을 조금 더 상세히 살펴보자.

암호화된 HTTP 메시지를 보내기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

![Image](https://res.craft.do/user/full/8884c80f-6eec-6a29-2a03-049def967beb/doc/2B90ADA3-92F6-4C08-9CA9-E85A6EC31E36/37A188C4-4524-4B1E-9770-AB9AA9BB0987_2/dE0tPOlleh7HXuY3nFT9b8pJ0n3UvRyZSATV6ftieksz/Image)

암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고받는다.

단순화한 SSL 핸드셰이크의 핵심은 다음과 같다.

- 클라이언트가 암호 후보들을 보내고 인증서를 요구한다.
- 서버는 선택된 암호와 인증서를 보낸다.
- 클라이언트가 비밀정보를 보낸다. 클라이언트와 서버는 키를 만든다.
- 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해준다.

### 서버 인증서

오늘날에는 클라이언트 인증서가 아닌 서버 인증서를 통해 안전한 통신을 한다.

보안 HTTPS 트랜젝션은 항상 서버 인증서를 요구한다. 서버에 신용카드나 개인정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는것을 도와줄 것이다.

## 진짜 HTTPS 클라이언트

SSL은 상당히 복잡한 바이너리 프로토콜이다.

**OpenSSL**

- OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다.

## 프락시를 통한 SSL 터널링

SSL은 바이너리 프로토콜이라고 설명했다. 프락시는 암호화된 메시지를 받으면 아무것도 할 수 없다. 어디로 보낼지에 대한 주소조차 알 수 없을것이다. 프락시는 메시지의 헤더에서 메시지가 어디로 전송되어야 하는지 알아야 하는데 암호화된 메시지는 읽어낼수가 없다. 이 때 HTTPS SSL 터널링 프로토콜을 사용한다.

HTTP는 CONNECT라는 확장 메서드를 사용하여 어디로 갈지 명시 한다

```other
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N
```

프락시는 이 CONNECT 메서드를 받으면 직접 대상으로 연결시켜주는 터널을 만들어 준다.

프락시까지는 일반적인 연결을 하고 프락시 부터 서버까지는 SSL 연결을 하는 구조라고 생각하면 될 것 같다.

